#多态
##方法调用绑定
* 前期绑定：在程序执行前（由编译器和连接程序实现），将一个方法同方法主体关联起来。
* 后期绑定：在运行时根据对象的类型进行绑定，也叫做动态绑定或运行时绑定。
* Java中除了final方法和static方法外，其他所有方法都是后期绑定。
### private方法不可以被覆盖，所以在导出类中对于基类的私有方法最好采用不同的名字。
###如果某个方法是静态的，他的行为就不具有多态性。
##构造器和多态
* 构造器不同与其他种类的方法，它实际上是static方法，只不过是隐式的，所以他不具有多态性。
### 构造器的调用顺序
```
基类的构造器总是在导出类的构造过程中被调用，并且按照继承层次逐渐向上连接，以使每个基类的
构造器都能得到调用。（这样做是有意义的，因为构造器具有一项特殊的任务：检查对象是否被正确
的创建，而且只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化，因此必须使所有
构造器都得到调用，否则就不可能正确构造出完整对象。
```
* 调用基类构造器，这个步骤会反复递归下去，直到最底层的导出类（Object）
* 按声明顺序调用成员初始化方法
* 调用导出类构造器的主体
## 继承与清理
通过组合和继承方法来创建新类时，不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行管理，如果确实遇到清理问题，必须用心为新类创建dispose()
方法，并且由于继承缘故，如果我们有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖dispose方法，当覆盖被继承类的dispose方法时，务必
要调用基类的dispose方法，否则基类的清理动作就不会发生。
### 初始化的实际过程
* 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零
* 如之前所述调用基类构造器
* 按照声明顺序调用成员的初始化方法
* 调用导出类的构造器主体
##协变返回类型
在导出类中的被覆盖方法可以返回积累方法的返回类型的某种到处类型。
## 向下转型与运行时类型识别（RTTI）
由于向上转型会丢失具体类型信息，作为子类的一些扩展方法就不能被访问，所以我们想通过向下转型获取
更具体的类型信息，可是这样做往往是不安全的，因为我们不知道一个基类的具体类型是什么，所以在Java语言中，所有的转型都会得到检查，
以便保证他是我们希望的类型，如果不是就会抛出ClassCastException（类转型异常）。在运行期间对类型进行检查的行为称作“RTTI”。
