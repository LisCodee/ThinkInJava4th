# 内部类
- 将一个类的定义放在另一个类的定义内部，就是内部类
## 创建内部类
- 方法：把类的定义置于外围类的里面。（见example中示例代码）
- 如果想从外部类的非静态方法之外的任意位置创建某个内部类对象，那么必须具体指明这个对象的类型：OuterClassName.InnerClassName
## 链接到外部类
- 内部类对象可以访问外部类对象的所有成员，内部类还拥有外部类的所有元素的访问权
 
上面是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，次内部类对象必定会秘密的补货一个指向那个外围类对象的引用。
当然编译器会帮助我们处理细节。
## 使用.this和.new（example中DotThis DotNew）
- 如果你想在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟远点和this。这会在编译器就被知晓并受到检查，没有任何运行时开销。
- 如果你想告知某些其他对象，去创建其某个内部类的对象，就需要使用.new语法
- 想要创建内部类对象，必须使用外部类的对象来创建该内部类对象。
- 在拥有外部类对象之前是不可能创建内部类对象的，但如果你创建的是嵌套类（静态内部类），它就不需要对外部类对象的引用。
## 内部类与向上转型
- 私有属性的内部类除了其外部类外没有人能访问它，甚至不能向下转型成私有属性内部类（除非是继承自它的子类）。
## 在方法和作用域内的内部类 
- 可以在一个方法里面后者在任意的作用域内定义内部类，这么做有两个理由： 
    * 你实现了某类型的接口，于是可以创建并返回对其的引用。
    * 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案。 

你可以这样使用内部类：
- 定义在方法中
- 定义在作用域内，此作用域在方法内部
- 一个实现了接口的匿名类
- 一个匿名类，扩展了有费默认构造器的类
- 一个匿名类，他执行字段初始化
- 一个匿名类，他通过实例初始化实现构造（匿名类不可能有构造器）
## 匿名内部类
- 如果一个匿名内部类想要使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的，否则不能通过编译。
- 可以通过实例初始化来为匿名类创建一个构造器的效果
- 匿名内部类与正规的继承有些首先，它既可以扩展类也可以实现接口，但不能两者皆备，如果实现接口也只能实现一个接口。
## 再访工厂方法
通过使用匿名内部类可以使得工厂方法更为简便。
## 嵌套类
如果不需要内部类对象与其外围类对象之间有联系，可以将内部类声明为static，这称为嵌套类。
- 创建嵌套类对象并不需要其外围类对象
- 不能从嵌套类的对象中访问非静态的外围类对象
- 嵌套类可以有静态数据和字段
## 接口内部的类
> 正常情况下，不能再接口内放置任何代码，但嵌套类可以作为接口的一部分。你放到接口内的任何类都自动的是public 和static的。你还可以使用嵌套类来放置测试代码。
```java
public class TestBed{
    public void f(){
        System.out.println("f()");
    }
    public static class Tester{
        public static void main(String[] args){
          TestBed t = new TestBed();
          t.f();
        }
    }
}
```
## 从多层嵌套类中访问外部类的成员
> 一个内部类被嵌套多少层并不重要，他能透明的访问所有他所嵌入的外围类的所有成员。
```java
class MNA{
    private void f(){}
    class A{
        private void g(){}
        public class B{
            void h(){
                g();
                f();
            }
        }
    }
}
public class MultiNestingAccess{
    public static void main(String[] args){
      MNA man = new MNA();
      MNA.A mnaa = man.new A();
      MNA.A.B mnaab = mnaa.new B();
      manaab.h();
    }
}
```
## 为什么需要内部类
- 每个内部类都能独立的继承子一个（接口的）实现，所以无论外围类是否已经继承了某个实现，对内部类都没有影响
- 内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立
- 在单个外围类中，可以让多个内部类以不同方式实现同一个接口，或继承同一个类
- 创建内部类对象的时刻并不依赖与外围类对象的创建
- 内部类并没有令人迷惑的"is-a"关系，他就是一个独立的实体。
## 闭包与回调
> 闭包是一个可调用的对象，他记录了一些信息，这些信息来自于创建他的作用域，通过这个定义，可以看出内部类是面向对象的闭包，因为他不仅包含外围类对象的信息，还自动拥有一个指向此外部类对象的引用，在此作用域
内，内部类有权操作所有成员。

