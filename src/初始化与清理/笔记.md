##初始化与清理
###通过构造器进行初始化
在创建对象时，如果其类有构造器，Java就会在用户有能力操作对象前自动调用相应的构造器从而保证初始化的进行。
####构造器的命名
* 采用与类名相同的名称。

`

    class Rock{
        Rock(){
            System.out.println("Rock");
        }
`

不接受任何参数的构造器叫做默认构造器（无参构造器），同时构造器可以接收参数。
* 构造器没有返回值类型（与返回值类型为void不同）
####方法重载
#####可以有多个方法名一致，但是参数类型（或者顺序）不同的方法。（每个重载方法都必须有一个独一无二的参数列表）
* 如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型会被提升，char类型不同，如果无法找到接收char类型的方法，则会把char类型转为int型
####默认构造器
* 如果你的类没有编写构造器，编译器会帮你自动创建一个无参构造器来帮助你创建一个“默认对象”，而一旦你定义了构造器，系统则不会帮你生成无参构造器。
#### this关键字
* this关键字在方法内部使用，表示“调用方法的那个对象”
```
eg:
public class Leaf{
    int i = 0;
    Leaf increment(){
        i++;
        return this;
    }
}
或者
public class Leaf{
    int i = 0;
    Leaf(int i){
        this.i = i; //解决重名冲突问题
    }
}
```
#### 在构造器中调用构造器
* 为了代码的复用，你可以在构造器中使用this调用其他构造器
```
eg:
    public class Flower{
        int x;
        float y;
        Flower(int x){
            this.x = x;
        }
        Flower(int x, float y){
            this(x);
            this.y = y;
        }
    }
```
* 但是构造器调用只能放在第一行，除构造器外其他方法无法调用构造器。
#### static含义
* 在static方法内部不能调用非静态方法，反过来可以，而static方法可以通过类本身来直接调用，有点类似C中的全局方法。
### 清理：终结处理和垃圾回收
* 对象有可能不被垃圾回收
* 垃圾回收不等于析构
* 垃圾回收只与内存有关
```
    finalize方法：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize方法，
    并且在下一次垃圾回收动作发生时才会真正回收对象占用的内存。一般只有在通过某种创建对象
    方式以外的方式为对象分配了空间时才会用到它。
```
* 如果Java虚拟机没有面临内存耗尽的情况，它是不会去耗费时间去执行垃圾回收来恢复内存的。
```
class Book{
    boolean checkedOut = false;
    Book(boolean checkedOut){
        this.checkedOut = checkedOut;
    }
    void checkIn(){
        checkedOut = false;
    }
    protected void finalize(){
        if(checkedOut){
            System.out.println("Error:checked out");
        }
    }
}
public class TerminationCondition {
    public static void main(String[] args) {
        Book novel = new Book(true);
        //正确清理
        novel.checkIn();
        //删除引用，忘记清理
        new Book(true);
        //强制调用垃圾回收
        System.gc();
    }
}
```
* System.gc()用于强制进行终结动作。
### 垃圾回收机制工作原理
* 垃圾回收机制对于提高对象的创建速度具有明显的效果，在某些程度上Java从堆分配空间的速度可以媲美其他语言从堆栈上分配空间的速度。这其中的原因就在于Java的垃圾回收器
  ，当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，从而尽量避免页面错误。通过这种方式
  实现了一种告诉的、有无限空间可供分配的堆模型。
#### 其他的垃圾回收机制
* 引用计数：简单但是速度很慢
```
    每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数器+1，当引用离开作用域
    或被置为null时-1.当发现某个对象的引用计数为0时就会释放其占用的空间。
    这种方法对于垃圾回收器而言，定位交互自引用的对象组工作量巨大，而且如果对象间存在循环
    引用，就可能出现本应该被回收的对象，引用计数器缺不为0.
```
