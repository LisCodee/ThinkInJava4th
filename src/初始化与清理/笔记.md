##初始化与清理
###通过构造器进行初始化
在创建对象时，如果其类有构造器，Java就会在用户有能力操作对象前自动调用相应的构造器从而保证初始化的进行。
####构造器的命名
* 采用与类名相同的名称。

`

    class Rock{
        Rock(){
            System.out.println("Rock");
        }
`

不接受任何参数的构造器叫做默认构造器（无参构造器），同时构造器可以接收参数。
* 构造器没有返回值类型（与返回值类型为void不同）
####方法重载
#####可以有多个方法名一致，但是参数类型（或者顺序）不同的方法。（每个重载方法都必须有一个独一无二的参数列表）
* 如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型会被提升，char类型不同，如果无法找到接收char类型的方法，则会把char类型转为int型
####默认构造器
* 如果你的类没有编写构造器，编译器会帮你自动创建一个无参构造器来帮助你创建一个“默认对象”，而一旦你定义了构造器，系统则不会帮你生成无参构造器。
#### this关键字
* this关键字在方法内部使用，表示“调用方法的那个对象”
```
eg:
public class Leaf{
    int i = 0;
    Leaf increment(){
        i++;
        return this;
    }
}
或者
public class Leaf{
    int i = 0;
    Leaf(int i){
        this.i = i; //解决重名冲突问题
    }
}
```
#### 在构造器中调用构造器
* 为了代码的复用，你可以在构造器中使用this调用其他构造器
```
eg:
    public class Flower{
        int x;
        float y;
        Flower(int x){
            this.x = x;
        }
        Flower(int x, float y){
            this(x);
            this.y = y;
        }
    }
```
* 但是构造器调用只能放在第一行，除构造器外其他方法无法调用构造器。
#### static含义
* 在static方法内部不能调用非静态方法，反过来可以，而static方法可以通过类本身来直接调用，有点类似C中的全局方法。
### 清理：终结处理和垃圾回收
* 对象有可能不被垃圾回收
* 垃圾回收不等于析构
* 垃圾回收只与内存有关
```
    finalize方法：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize方法，
    并且在下一次垃圾回收动作发生时才会真正回收对象占用的内存。一般只有在通过某种创建对象
    方式以外的方式为对象分配了空间时才会用到它。
```
* 如果Java虚拟机没有面临内存耗尽的情况，它是不会去耗费时间去执行垃圾回收来恢复内存的。
```
class Book{
    boolean checkedOut = false;
    Book(boolean checkedOut){
        this.checkedOut = checkedOut;
    }
    void checkIn(){
        checkedOut = false;
    }
    protected void finalize(){
        if(checkedOut){
            System.out.println("Error:checked out");
        }
    }
}
public class TerminationCondition {
    public static void main(String[] args) {
        Book novel = new Book(true);
        //正确清理
        novel.checkIn();
        //删除引用，忘记清理
        new Book(true);
        //强制调用垃圾回收
        System.gc();
    }
}
```
* System.gc()用于强制进行终结动作。
### 垃圾回收机制工作原理
* 垃圾回收机制对于提高对象的创建速度具有明显的效果，在某些程度上Java从堆分配空间的速度可以媲美其他语言从堆栈上分配空间的速度。这其中的原因就在于Java的垃圾回收器
  ，当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，从而尽量避免页面错误。通过这种方式
  实现了一种告诉的、有无限空间可供分配的堆模型。
#### 其他的垃圾回收机制
#### 引用计数：简单但是速度很慢
```
    每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数器+1，当引用离开作用域
    或被置为null时-1.当发现某个对象的引用计数为0时就会释放其占用的空间。
    这种方法对于垃圾回收器而言，定位交互自引用的对象组工作量巨大，而且如果对象间存在循环
    引用，就可能出现本应该被回收的对象，引用计数器缺不为0.
```
#### 停止-复制
##### 那么如何找到所有的活的对象呢
```
    对任何活的对象，一定能追溯到其存活在堆栈或静态存储区域之中的引用，这个引用链可能穿过数个
    对象层次，由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有活的对象，对于
    发现的每个引用必须跟踪它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到
    “根源于堆栈和静态存储区的引用“所形成的的网络全部被访问为止。
```
* 在这种方式下，停止-复制意味着先暂停程序的运行，然后将所有存活的对象从当前堆复制到
另一个堆，没有被复制的全是垃圾，当对象被分配到新堆时，他们是紧凑排列的，就可以按先前的方法
直接分配新空间了。
- 停止-复制的效率比较低，究其原因，首先要有两个堆，然后在这两个分离的堆之间来回倒腾，从而维护比实际需要多一倍的空间。
一些JVM对此的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之中。
第二个问题在于复制，程序进入稳定状态后，可能只会产生少量垃圾，尽管如此，复制式回收器仍然把所有内存自一处复制到另一处
，这很浪费，为避免此类情况，如果没有新垃圾产生，就会切换到另一种工作模式--标记清扫模式。
#### 标记清扫
```
    标记-清扫的工作方式同样是从堆栈和静态存储区出发，遍历所有引用，找出所有存活的对象并设置
    标记，当所有标记工作完成时，没有标记的对象将会被释放，这样剩下的堆空间是不连续的。
```
* 自适应的，分代的，停止-复制，标记-清扫式垃圾回收器
#### 即时编译技术（JIT)
```
   这种技术可以把程序全部或部分翻译成本地机器码，运行速度得以提升。当需要装载某个类时，编译
   器会找到其.class文件，将该类的字节码装入内存，此时有两种方案可供选择。
   1. 让即时编译器编译所有代码。这种加载散落在整个程序的生命周期，累加起来要花更多时间，而且
   会增加可执行代码的长度，将会导致页面调度，降低程序速度。
   2.惰性评估。只有在必要时才编译代码，这样，从不执行的代码也许根本就不会编译。代码每次被执行
   的时候都会做一些优化，所以执行次数越多，速度就越快。
```
#### 初始化顺序
* 在类的内部，变量定义的先后顺序决定了初始化的顺序，并且会在方法被调用之前得到初始化。
#### 静态数据初始化
* 静态数据只有在必要时候才进行，只有对象被创建或者第一次访问静态数据的时候才会进行初始化，此后不会再被初始化。
* 初始化的顺序先是静态对象，然后是非静态对象。
* 构造器可以看成静态方法
* 静态初始化只在Class对象首次加载的时候执行一次
```
    1.类加载，静态初始化
    2.创建对象后，自动初始化（基本类型置零，引用置null)
    3.字段定义出的初始化
    4.执行构造器
```
#### 非静态区域初始化
* 类似静态初始胡句子，没有static关键字，使得你无论调用哪个构造器，某些操作都会执行。
#### 数组初始化
略
#### 可变参数列表
* 基本语法
```
    void printArray(Object... args){
        for(Object o: args)
            System.out.println(o);
    }
```
* 可变参数列表可以不传任何参数，如此转变后的尺寸为0
* 你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不使用它
#### 枚举类型
同C、C++中的枚举类型相似
* 基本语法
```
public enum Spiciness{
    NOT,MILD,MEDIUM,HOT,FLAMING //定义枚举类型
}
```
```
Spiciness howHot = Spiciness.MEDIUM //引用枚举类型
```
* ordinal方法：表示某个特定枚举常量的声明顺序
* static values方法：用来按照枚举常量的声明顺序，产生由这些常量值构成的数组
* 枚举类型配合switch使用十分实用